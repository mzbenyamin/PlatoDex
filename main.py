from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InlineQueryResultArticle, InputTextMessageContent, InputFile, error
from telegram.ext import Application, CommandHandler, ContextTypes, InlineQueryHandler, CallbackQueryHandler, MessageHandler, filters, ConversationHandler
import requests
from bs4 import BeautifulSoup
import json
import re
import html
import logging
import asyncio
import time
from fastapi import FastAPI, Request
from PIL import Image
import io
import tempfile
import os
import random
from typing import List, Dict, Optional, Union
import uvicorn
import sqlite3
import queue
import threading

# ØªÙ†Ø¸ÛŒÙ… Ù„Ø§Ú¯
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# ØªÙˆÚ©Ù† Ùˆ Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§
TOKEN = '7764880184:AAEAp5oyNfB__Cotdmtxb9BHnWgwydRN0ME'
IMAGE_API_URL = 'https://pollinations.ai/prompt/'
TEXT_API_URL = 'https://text.pollinations.ai/'
URL = "https://platopedia.com/items"
BASE_IMAGE_URL = "https://profile.platocdn.com/"
WEBHOOK_URL = "https://platodex.onrender.com/webhook"
EXTRACTED_ITEMS = []
AI_CHAT_USERS = set()
SEARCH_ITEM, SELECT_CATEGORY = range(2)
SELECT_SIZE, GET_PROMPT = range(2, 4)
DEFAULT_CHAT_ID = 789912945
PROCESSED_MESSAGES = set()
PROCESSING_LOCK = asyncio.Lock()  # ØªØºÛŒÛŒØ± Ø¨Ù‡ asyncio.Lock

# --- Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø±ÙˆÙ‡ Ùˆ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ---
ADMIN_ID = 7403352779  # Admin user ID

def init_db():
    conn = sqlite3.connect('violations.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS violations (
            user_id TEXT,
            username TEXT,
            message TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS settings (
            key TEXT PRIMARY KEY,
            value TEXT
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS chat_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            chat_id TEXT,
            user_id TEXT,
            username TEXT,
            message TEXT,
            reply_to_message_id TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    cursor.execute('INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)', ('response_triggers', ''))
    cursor.execute('INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)', ('no_response_triggers', ''))
    cursor.execute('INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)', ('violation_triggers', ''))
    cursor.execute('INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)', ('no_violation_triggers', ''))
    conn.commit()
    conn.close()
    logger.info("Database initialized")

def get_setting(key, default=''):
    conn = sqlite3.connect('violations.db')
    cursor = conn.cursor()
    cursor.execute('SELECT value FROM settings WHERE key = ?', (key,))
    result = cursor.fetchone()
    conn.close()
    return result[0] if result else default

def update_setting(key, value):
    conn = sqlite3.connect('violations.db')
    cursor = conn.cursor()
    cursor.execute('INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)', (key, value))
    conn.commit()
    conn.close()
    logger.info(f"Setting updated: {key} = {value}")

def count_violations(user_id):
    conn = sqlite3.connect('violations.db')
    cursor = conn.cursor()
    cursor.execute('SELECT COUNT(*) FROM violations WHERE user_id = ?', (user_id,))
    count = cursor.fetchone()[0]
    conn.close()
    return count

def log_violation(user_id, username, message):
    conn = sqlite3.connect('violations.db')
    cursor = conn.cursor()
    cursor.execute('INSERT INTO violations (user_id, username, message) VALUES (?, ?, ?)',
                   (user_id, username, message))
    conn.commit()
    conn.close()
    logger.info(f"Violation logged for user {user_id} ({username}): {message}")

def clear_violations(user_id):
    conn = sqlite3.connect('violations.db')
    cursor = conn.cursor()
    cursor.execute('DELETE FROM violations WHERE user_id = ?', (user_id,))
    conn.commit()
    conn.close()
    logger.info(f"Violations cleared for user {user_id}")

def add_to_chat_history(chat_id, user_id, username, message, reply_to_message_id=None):
    conn = sqlite3.connect('violations.db')
    cursor = conn.cursor()
    cursor.execute('SELECT COUNT(*) FROM chat_history')
    count = cursor.fetchone()[0]
    if count >= 1000:
        cursor.execute('DELETE FROM chat_history WHERE id = (SELECT MIN(id) FROM chat_history)')
    cursor.execute('''
        INSERT INTO chat_history (chat_id, user_id, username, message, reply_to_message_id)
        VALUES (?, ?, ?, ?, ?)
    ''', (chat_id, user_id, username, message, reply_to_message_id))
    conn.commit()
    conn.close()
    logger.info(f"Message added to chat history for user {user_id} (@{username})")

def get_recent_chat_history(chat_id, limit=10):
    conn = sqlite3.connect('violations.db')
    cursor = conn.cursor()
    cursor.execute('''
        SELECT user_id, username, message, reply_to_message_id, timestamp
        FROM chat_history
        WHERE chat_id = ?
        ORDER BY timestamp DESC
        LIMIT ?
    ''', (chat_id, limit))
    history = cursor.fetchall()
    conn.close()
    return history

# --- ØµÙ API ---
api_queue = queue.Queue()
def process_api_queue():
    while True:
        try:
            text, model, callback = api_queue.get()
            logger.info(f"Processing API request: {text[:50]}...")
            url = f"https://text.pollinations.ai/{text}&model={model}"
            for attempt in range(3):
                try:
                    response = requests.get(url)
                    response.raise_for_status()
                    logger.info(f"API response: {response.text[:50]}...")
                    callback(response.text.strip())
                    time.sleep(2)
                    break
                except requests.HTTPError as e:
                    if e.response.status_code == 429:
                        logger.warning(f"Rate limit hit, retrying after {2 * (attempt + 1)} seconds...")
                        time.sleep(2 * (attempt + 1))
                        continue
                    else:
                        logger.error(f"HTTP Error: {e}")
                        callback(None)
                        break
                except requests.RequestException as e:
                    logger.error(f"Request Error: {e}")
                    callback(None)
                    break
            else:
                logger.error("Failed after retries.")
                callback(None)
            api_queue.task_done()
        except Exception as e:
            logger.error(f"Error in API queue: {e}")
threading.Thread(target=process_api_queue, daemon=True).start()
def analyze_message(text, model='openai', callback=lambda x: None):
    api_queue.put((text, model, callback))

def should_respond_or_violate(text, bot_username, user_id, username, callback):
    response_triggers = get_setting('response_triggers', '')
    no_response_triggers = get_setting('no_response_triggers', '')
    violation_triggers = get_setting('violation_triggers', '')
    no_violation_triggers = get_setting('no_violation_triggers', '')
    logger.info(f"Analyzing message from {user_id} (@{username}): {text}")
    prompt = f"""
    Ø´Ù…Ø§ ÛŒÚ© Ø¯Ø³ØªÛŒØ§Ø± Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¯Ø± Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…ÛŒ Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ø¨Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø±ÙˆÙ‡ Ú©Ù…Ú© Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯ Ùˆ Ø¨Ù‡ Ø³ÙˆØ§Ù„Ø§Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ù¾Ø§Ø³Ø® Ù…ÛŒâ€ŒØ¯Ù‡ÛŒØ¯.
    Ù¾ÛŒØ§Ù… Ø²ÛŒØ± Ø±Ø§ ØªØ­Ù„ÛŒÙ„ Ú©Ù†ÛŒØ¯ Ùˆ ØªØµÙ…ÛŒÙ… Ø¨Ú¯ÛŒØ±ÛŒØ¯:
    1. Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… Ø´Ø§Ù…Ù„ Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ ÛŒØ§ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¨Ø§Ø´Ø¯: {response_triggers}ØŒ ÛŒØ§ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø®Ø·Ø§Ø¨ Ø¨Ù‡ Ø±Ø¨Ø§Øª Ø¨Ø§Ø´Ø¯ (Ù…Ø«Ù„Ø§Ù‹ Ø¨Ø§ Ù…Ù†Ø´Ù† ÛŒØ§ Ø¯Ø± Ú†Øª Ø®ØµÙˆØµÛŒ)ØŒ Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯.
    2. Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… Ø´Ø§Ù…Ù„ Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ø²ÛŒØ± Ø¨Ø§Ø´Ø¯: {no_response_triggers}ØŒ Ù¾Ø§Ø³Ø® Ù†Ø¯Ù‡ÛŒØ¯.
    3. Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… Ø´Ø§Ù…Ù„ Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ ÛŒØ§ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¨Ø§Ø´Ø¯: {violation_triggers}ØŒ Ø¢Ù† Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ØªØ®Ù„Ù Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯.
    4. Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… Ø´Ø§Ù…Ù„ Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ø²ÛŒØ± Ø¨Ø§Ø´Ø¯: {no_violation_triggers}ØŒ Ø¢Ù† Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ØªØ®Ù„Ù Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù†Ú©Ù†ÛŒØ¯.
    Ù‡Ù…Ú†Ù†ÛŒÙ†ØŒ Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… ÛŒÚ© Ø³ÙˆØ§Ù„ Ù…Ù‡Ù… Ø§Ø³Øª Ú©Ù‡ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ù¾Ø§Ø³Ø® Ø¯Ø§Ø±Ø¯ØŒ Ø§Ù…Ø§ Ù…Ø·Ù…Ø¦Ù† Ù†ÛŒØ³ØªÛŒØ¯ Ú©Ù‡ Ø¨Ø§ÛŒØ¯ Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯ØŒ Ø§Ø² Ú©Ø§Ø±Ø¨Ø± Ø§Ø¬Ø§Ø²Ù‡ Ø¨Ú¯ÛŒØ±ÛŒØ¯.
    Ù…ØªÙ† Ù¾ÛŒØ§Ù…: {text}
    Ù¾Ø§Ø³Ø® Ø´Ù…Ø§ Ø¨Ø§ÛŒØ¯ ÛŒÚ©ÛŒ Ø§Ø² Ù…ÙˆØ§Ø±Ø¯ Ø²ÛŒØ± Ø¨Ø§Ø´Ø¯:
    - 'Ù¾Ø§Ø³Ø® Ø¨Ø¯Ù‡': Ø§Ú¯Ø± Ø¨Ø§ÛŒØ¯ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯
    - 'Ø§Ø¬Ø§Ø²Ù‡ Ø¨Ú¯ÛŒØ±': Ø§Ú¯Ø± Ø¨Ø§ÛŒØ¯ Ø§Ø² Ú©Ø§Ø±Ø¨Ø± Ø§Ø¬Ø§Ø²Ù‡ Ø¨Ú¯ÛŒØ±ÛŒØ¯
    - 'ØªØ®Ù„Ù': Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… ØªØ®Ù„Ù Ø§Ø³Øª
    - 'Ù‡ÛŒÚ†ÛŒ': Ø§Ú¯Ø± Ù‡ÛŒÚ† Ú©Ø¯Ø§Ù… Ø§Ø² Ù…ÙˆØ§Ø±Ø¯ Ø¨Ø§Ù„Ø§ ØµØ¯Ù‚ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯
    """
    analyze_message(prompt, model='openai', callback=callback)

def generate_response(text, user_id, username, callback, chat_history=None):
    response_triggers = get_setting('response_triggers', '')
    logger.info(f"Generating response for {user_id} (@{username}): {text}")
    history_context = ""
    if chat_history:
        history_context = "\nØªØ§Ø±ÛŒØ®Ú†Ù‡ Ú†Øª Ø§Ø®ÛŒØ±:\n"
        for msg in chat_history:
            history_context += f"@{msg[1]}: {msg[2]}\n"
    prompt = f"""
    Ø´Ù…Ø§ Ø¯Ø³ØªÛŒØ§Ø± Ù‡ÙˆØ´Ù…Ù†Ø¯ PlatoDex Ù‡Ø³ØªÛŒØ¯ Ùˆ Ø¯Ø±Ù…ÙˆØ±Ø¯ Ù¾Ù„Ø§ØªÙˆ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ú©Ù…Ú© Ù…ÛŒÚ©Ù†ÛŒØ¯ Ùˆ Ø¨Ù‡ ØµÙˆØ±Øª Ø®ÙˆØ¯Ù…ÙˆÙ†ÛŒ Ø¬Ø°Ø§Ø¨ Ùˆ Ø¨Ø§ Ø§ÛŒÙ…ÙˆØ¬ÛŒ Ø­Ø±Ù Ù…ÛŒØ²Ù†ÛŒ Ø¨Ù‡ ØµÙˆØ±Øª Ù†Ø³Ù„ Z Ùˆ Ú©Ù…ÛŒ Ø¨Ø§ Ø·Ù†Ø² Ø­Ø±Ù Ø¨Ø²Ù† Ùˆ Ø´ÙˆØ®ÛŒ Ú©Ù†Ù‡. Ø¨Ù‡ Ù…Ø´Ø®ØµØ§Øª Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ù¾Ù„Ø§ØªÙˆ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯Ø§Ø±ÛŒ Ùˆ Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø¨Ù‡ Ø³ÙˆØ§Ù„Ø§Øª Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± Ù…ÙˆØ±Ø¯ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø¬ÙˆØ§Ø¨ Ø¨Ø¯ÛŒ Ùˆ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒ Ú©Ù†ÛŒ Ú†Ø·ÙˆØ± Ø¨Ø§ Ø¯Ø³ØªÙˆØ± /i Ù…Ø´Ø®ØµØ§Øª Ú©Ø§Ù…Ù„ Ø±Ùˆ Ø¨Ú¯ÛŒØ±Ù†.
    ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù¾ÛŒØ§Ù… Ú©Ø§Ø±Ø¨Ø±Ø§Ù† :{history_context}
    Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ÛŒÚ© Ø¯Ø³ØªÛŒØ§Ø± Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ùˆ Ø¯ÙˆØ³ØªØ§Ù†Ù‡:
    - Ù¾Ø§Ø³Ø® Ø¨Ø§ÛŒØ¯ Ú©ÙˆØªØ§Ù‡ØŒ Ø¯Ù‚ÛŒÙ‚ Ùˆ Ø¬Ø°Ø§Ø¨ Ø¨Ø§Ø´Ø¯
    - Ø§Ø² Ø§ÛŒÙ…ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
    - Ø¨Ø§ Ù„Ø­Ù† Ù†Ø³Ù„ Z Ùˆ Ø¯ÙˆØ³ØªØ§Ù†Ù‡ ØµØ­Ø¨Øª Ú©Ù†
    - Ø§Ú¯Ø± Ø³ÙˆØ§Ù„ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ ({response_triggers}) Ø¨Ø§Ø´Ø¯ØŒ Ù¾Ø§Ø³Ø® Ù…Ø±ØªØ¨Ø· Ø¨Ø¯Ù‡
    - Ø§Ú¯Ø± Ù†ÛŒØ§Ø² Ø§Ø³ØªØŒ Ù‡Ø´Ø¯Ø§Ø± Ø¯Ù‡ÛŒØ¯ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ù‚ÛŒÙ‚â€ŒØªØ± Ø¨Ø§ Ù…ØªØ®ØµØµ Ù…Ø´ÙˆØ±Øª Ú©Ù†Ù†Ø¯
    - Ø§Ú¯Ø± Ø³ÙˆØ§Ù„ÛŒ Ø§Ø³Øª Ú©Ù‡ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø§Ø¬Ø§Ø²Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø§Ø±Ø¯ØŒ Ø§Ø² Ø§Ùˆ Ø§Ø¬Ø§Ø²Ù‡ Ø¨Ú¯ÛŒØ±ÛŒØ¯
    - Ø§Ú¯Ø± Ø³ÙˆØ§Ù„ Ø¯Ø± Ù…ÙˆØ±Ø¯ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ù¾Ù„Ø§ØªÙˆ Ø§Ø³ØªØŒ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒ Ú©Ù† Ú©Ù‡ Ø§Ø² Ø¯Ø³ØªÙˆØ± /i Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ù†Ø¯
    - Ø§Ú¯Ø± Ø³ÙˆØ§Ù„ Ø¯Ø± Ù…ÙˆØ±Ø¯ Ú†Ù†Ø¯ Ø§Ú©Ø§Ù†Øª Ø§Ø³ØªØŒ ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù‡ Ú©Ù‡ Ø§Ø² ØªØ§Ø±ÛŒØ® 28 ÙØ±ÙˆØ±Ø¯ÛŒÙ† 1404 Ù¾Ù„Ø§ØªÙˆ Ø³Ø±ÙˆØ±Ù‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯
    - Ø§Ú¯Ø± Ø³ÙˆØ§Ù„ Ø¯Ø± Ù…ÙˆØ±Ø¯ Ø¯ÙˆØ³ØªØ§Ù† Ø§Ø³ØªØŒ ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù‡ Ú©Ù‡ Ø¯ÛŒÚ¯Ø± Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¯ÙˆØ³ØªØ§Ù† Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¯ÛŒÚ¯Ø± Ø±Ø§ Ø¯ÛŒØ¯
    - Ø§Ú¯Ø± Ø³ÙˆØ§Ù„ Ø¯Ø± Ù…ÙˆØ±Ø¯ Ø³Ù„Ø§Ø·ÛŒÙ† Ù¾Ù„Ø§ØªÙˆ Ø§Ø³ØªØŒ ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù‡ Ú©Ù‡ Ø§ÙˆÙ„ÛŒÙ† Ø±Ø³Ø§Ù†Ù‡ ÙØ§Ø±Ø³ÛŒâ€ŒØ²Ø¨ÙˆÙ† Ù¾Ù„Ø§ØªÙˆ Ø§Ø² 1400 Ø¨Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ù†ÛŒØ§Ù…ÛŒÙ† Ø§Ø³Øª
    Ù¾ÛŒØ§Ù…: {text}
    Ù…Ø«Ø§Ù„:
    Ù¾ÛŒØ§Ù…: "Ø³ÙˆØ§Ù„ Ø¯Ø§Ø±Ù…"
    Ù¾Ø§Ø³Ø®: "Ø³Ù„Ø§Ù…! ğŸ˜Š Ú†Ø·ÙˆØ± Ù…ÛŒâ€ŒØªÙˆÙ†Ù… Ú©Ù…Ú©Øª Ú©Ù†Ù…ØŸ Ù‡Ø± Ø³ÙˆØ§Ù„ÛŒ Ø¯Ø§Ø±ÛŒ Ø¨Ù¾Ø±Ø³ØŒ Ù…Ù† Ø§ÛŒÙ†Ø¬Ø§Ù… ØªØ§ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒØª Ú©Ù†Ù…! ğŸ®âœ¨"
    """
    analyze_message(prompt, model='openai', callback=callback)

def generate_violation_reason(text, callback):
    prompt = f"""
    Ø´Ù…Ø§ ÛŒÚ© Ø¯Ø³ØªÛŒØ§Ø± Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¯Ø± Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…ÛŒ Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ø¨Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø±ÙˆÙ‡ Ú©Ù…Ú© Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯.
    Ù¾ÛŒØ§Ù… Ø²ÛŒØ± Ø±Ø§ ØªØ­Ù„ÛŒÙ„ Ú©Ù†ÛŒØ¯ Ùˆ Ø¯Ù„ÛŒÙ„ Ø¯Ù‚ÛŒÙ‚ ØªØ®Ù„Ù Ø±Ø§ ØªÙˆØ¶ÛŒØ­ Ø¯Ù‡ÛŒØ¯:
    - Ø¯Ù„ÛŒÙ„ Ø¨Ø§ÛŒØ¯ ÙˆØ§Ø¶Ø­ Ùˆ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ø¨Ø§Ø´Ø¯
    - Ø­Ø¯Ø§Ú©Ø«Ø± 50 Ú©Ù„Ù…Ù‡ Ø¨Ø§Ø´Ø¯
    - Ø§Ø² Ú©Ù„Ù…Ø§Øª ØªÙˆÙ‡ÛŒÙ†â€ŒØ¢Ù…ÛŒØ² Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ú©Ù†ÛŒØ¯
    - Ø¯Ù„ÛŒÙ„ Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ ØµÙˆØ±Øª Ù…Ø³ØªÙ‚ÛŒÙ… Ùˆ Ø¨Ø¯ÙˆÙ† Ø§Ø¨Ù‡Ø§Ù… Ø¨Ø§Ø´Ø¯
    Ù…ØªÙ† Ù¾ÛŒØ§Ù…: {text}
    Ù…Ø«Ø§Ù„:
    Ù¾ÛŒØ§Ù…: "Ø³Ù„Ø§Ù… Ø¨Ù‡ Ù‡Ù…Ù‡"
    Ø¯Ù„ÛŒÙ„: Ù¾ÛŒØ§Ù… Ø®Ø§Ù„ÛŒ ÛŒØ§ Ø¨ÛŒâ€ŒÙ…Ø­ØªÙˆØ§
    Ù¾ÛŒØ§Ù…: "Ù„ÛŒÙ†Ú© Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙÛŒÙ„Ù…"
    Ø¯Ù„ÛŒÙ„: Ø§Ø±Ø³Ø§Ù„ Ù„ÛŒÙ†Ú© ØºÛŒØ±Ù…Ø¬Ø§Ø² Ùˆ ØªØ¨Ù„ÛŒØºØ§Øª
    """
    analyze_message(prompt, model='openai', callback=callback)

# --- Ø¯Ø³ØªÙˆØ±Ø§Øª Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ ---
from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove

async def admin_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "Unknown"
    if update.message.chat.type == 'private' and user_id == ADMIN_ID:
        keyboard = [
            ['ØªÙ†Ø¸ÛŒÙ… Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§', 'ØªÙ†Ø¸ÛŒÙ… ØªØ®Ù„Ùâ€ŒÙ‡Ø§'],
            ['ØªÙ†Ø¸ÛŒÙ… Ø¹Ø¯Ù… Ù¾Ø§Ø³Ø®', 'ØªÙ†Ø¸ÛŒÙ… Ø¹Ø¯Ù… ØªØ®Ù„Ù'],
            ['ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª', 'Ø®Ø±ÙˆØ¬']
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
        await update.message.reply_text(
            "<b>Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ Ø±Ø¨Ø§Øª</b>\nØ§Ø² Ø§ÛŒÙ† Ù…Ù†Ùˆ Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒØ¯ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±Ø¨Ø§Øª Ø±Ùˆ ØªØºÛŒÛŒØ± Ø¨Ø¯ÛŒØ¯.",
            parse_mode='HTML',
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            "<b>Ø³Ù„Ø§Ù…!</b> Ù…Ù† Ø±Ø¨Ø§Øª Ú¯Ø±ÙˆÙ‡ Ù‡Ø³ØªÙ…. Ø¨Ø±Ø§ÛŒ Ø³ÙˆØ§Ù„ØŒ Ù…Ù† Ø±Ùˆ Ù…Ù†Ø´Ù† Ú©Ù†ÛŒØ¯ ÛŒØ§ ØªÙˆÛŒ Ú†Øª Ø®ØµÙˆØµÛŒ Ù¾ÛŒØ§Ù… Ø¨Ø¯ÛŒØ¯.",
            parse_mode='HTML'
        )

async def warn(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "Unknown"
    if not update.message.from_user:
        await update.message.reply_text("Ú©Ø§Ø±Ø¨Ø± Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù†Ø´Ø¯.", parse_mode='HTML')
        return
    if not context.args:
        await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø±Ùˆ Ø°Ú©Ø± Ú©Ù†ÛŒØ¯ØŒ Ù…Ø«Ù„Ø§Ù‹: /warn @username", parse_mode='HTML')
        return
    target_username = context.args[0].replace('@', '')
    target_user_id = None
    async for member in context.bot.get_chat_members(update.message.chat_id):
        if member.user.username == f"@{target_username}":
            target_user_id = str(member.user.id)
            break
    if not target_user_id:
        await update.message.reply_text("Ú©Ø§Ø±Ø¨Ø± Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯.", parse_mode='HTML')
        return
    log_violation(target_user_id, target_username, "Ø§Ø®Ø·Ø§Ø± Ø¯Ø³ØªÛŒ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†")
    violation_count = count_violations(target_user_id)
    await update.message.reply_text(
        f"<b>âš ï¸ ØªØ®Ù„Ù Ùˆ Ø§Ø®Ø·Ø§Ø±</b>\n\nÚ©Ø§Ø±Ø¨Ø± <a href='tg://user?id={target_user_id}'>@{target_username}</a> Ø´Ù…Ø§ ÛŒÚ© Ø®Ø·Ø§ Ø¯Ø±ÛŒØ§ÙØª Ú©Ø±Ø¯ÛŒØ¯\n\n<b>ğŸ“‡ Ø¹Ù„Øª:</b> Ø§Ø®Ø·Ø§Ø± Ø¯Ø³ØªÛŒ\n\n<b>â—ï¸Ø§Ø®Ø·Ø§Ø±Ù‡Ø§ÛŒ Ø´Ù…Ø§:</b> {violation_count}",
        parse_mode='HTML'
    )

async def violations(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "Unknown"
    if not context.args:
        await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø±Ùˆ Ø°Ú©Ø± Ú©Ù†ÛŒØ¯ØŒ Ù…Ø«Ù„Ø§Ù‹: /violations @username", parse_mode='HTML')
        return
    target_username = context.args[0].replace('@', '')
    target_user_id = None
    async for member in context.bot.get_chat_members(update.message.chat_id):
        if member.user.username == f"@{target_username}":
            target_user_id = str(member.user.id)
            break
    if not target_user_id:
        await update.message.reply_text("Ú©Ø§Ø±Ø¨Ø± Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯.", parse_mode='HTML')
        return
    count = count_violations(target_user_id)
    await update.message.reply_text(
        f"Ú©Ø§Ø±Ø¨Ø± <a href='tg://user?id={target_user_id}'>@{target_username}</a> <b>{count}</b> ØªØ®Ù„Ù Ø¯Ø§Ø±Ù‡.",
        parse_mode='HTML'
    )

async def clear_violations_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "Unknown"
    if not context.args:
        await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø±Ùˆ Ø°Ú©Ø± Ú©Ù†ÛŒØ¯ØŒ Ù…Ø«Ù„Ø§Ù‹: /clearviolations @username", parse_mode='HTML')
        return
    target_username = context.args[0].replace('@', '')
    target_user_id = None
    async for member in context.bot.get_chat_members(update.message.chat_id):
        if member.user.username == f"@{target_username}":
            target_user_id = str(member.user.id)
            break
    if not target_user_id:
        await update.message.reply_text("Ú©Ø§Ø±Ø¨Ø± Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯.", parse_mode='HTML')
        return
    clear_violations(target_user_id)
    await update.message.reply_text(
        f"ØªØ®Ù„Ùâ€ŒÙ‡Ø§ÛŒ <a href='tg://user?id={target_user_id}'>@{target_username}</a> Ù¾Ø§Ú© Ø´Ø¯.",
        parse_mode='HTML'
    )

# --- Ù‡Ù†Ø¯Ù„Ø± Ù¾ÛŒØ§Ù… Ù…ØªÙ†ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ ---
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_text = update.message.text
    bot_username = context.bot.username
    chat_id = update.message.chat_id
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "Unknown"
    message_id = update.message.message_id
    add_to_chat_history(chat_id, user_id, username, message_text, message_id)
    chat_history = get_recent_chat_history(chat_id)
    # Ø§Ú¯Ø± Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ø±Ø¨Ø§Øª Ù…Ø±Ø¨ÙˆØ· Ø¨ÙˆØ¯ ÛŒØ§ Ø¯Ø± Ú†Øª Ø®ØµÙˆØµÛŒ Ø¨ÙˆØ¯
    if f"@{bot_username}" in message_text or update.message.chat.type == 'private':
        def callback(reply):
            if reply and context.job_queue:
                context.job_queue.run_once(
                    lambda ctx: ctx.bot.send_message(
                        chat_id=chat_id,
                        text=reply,
                        parse_mode='HTML',
                        reply_to_message_id=message_id
                    ),
                    0
                )
        generate_response(message_text, user_id, username, callback, chat_history)
    else:
        def callback(decision):
            if not decision:
                return
            decision = decision.lower()
            if 'Ù¾Ø§Ø³Ø® Ø¨Ø¯Ù‡' in decision:
                def reply_callback(reply):
                    if reply and context.job_queue:
                        context.job_queue.run_once(
                            lambda ctx: ctx.bot.send_message(
                                chat_id=chat_id,
                                text=reply,
                                parse_mode='HTML',
                                reply_to_message_id=message_id
                            ),
                            0
                        )
                generate_response(message_text, user_id, username, reply_callback, chat_history)
            elif 'Ø§Ø¬Ø§Ø²Ù‡ Ø¨Ú¯ÛŒØ±' in decision:
                keyboard = [[InlineKeyboardButton("Ø¨Ù„Ù‡", callback_data=f"allow_{user_id}"),
                           InlineKeyboardButton("Ø®ÛŒØ±", callback_data=f"deny_{user_id}")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                context.job_queue.run_once(
                    lambda ctx: ctx.bot.send_message(
                        chat_id=chat_id,
                        text=f"Ú©Ø§Ø±Ø¨Ø± {update.message.from_user.mention_html()}ØŒ Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø¨Ù‡ Ø³ÙˆØ§Ù„ Ø´Ù…Ø§ Ù¾Ø§Ø³Ø® Ø¯Ù‡Ù…ØŸ",
                        parse_mode='HTML',
                        reply_to_message_id=message_id,
                        reply_markup=reply_markup
                    ),
                    0
                )
            elif 'ØªØ®Ù„Ù' in decision:
                log_violation(str(user_id), username, message_text)
                violation_count = count_violations(str(user_id))
                def violation_reason_callback(reason):
                    if not reason:
                        reason = "Ù…Ø­ØªÙˆØ§ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø² ÛŒØ§ ØªØ®Ù„Ù Ø§Ø² Ù‚ÙˆØ§Ù†ÛŒÙ†"
                    context.job_queue.run_once(
                        lambda ctx: ctx.bot.send_message(
                            chat_id=chat_id,
                            text=f"âš ï¸ <b>Ø§Ø®Ø·Ø§Ø±</b>\n\n"
                                 f"{update.message.from_user.mention_html()} Ø´Ù…Ø§ ÛŒÚ© Ø§Ø®Ø·Ø§Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø±Ø¯ÛŒØ¯\n\n"
                                 f"ğŸ“‡ <b>Ø¹Ù„Øª:</b> {reason}\n\n"
                                 f"â—ï¸<b>ØªØ¹Ø¯Ø§Ø¯ Ø§Ø®Ø·Ø§Ø±Ù‡Ø§ÛŒ Ø´Ù…Ø§:</b> {violation_count}",
                            parse_mode='HTML',
                            reply_to_message_id=message_id
                        ),
                        0
                    )
                generate_violation_reason(message_text, violation_reason_callback)
        should_respond_or_violate(message_text, bot_username, user_id, username, callback)

# --- Ù‡Ù†Ø¯Ù„Ø± CallbackQuery Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø§Ø²Ù‡ Ù¾Ø§Ø³Ø® ---
async def handle_callback_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data.startswith('allow_'):
        user_id = query.data.split('_')[1]
        message = query.message.reply_to_message
        if message:
            def reply_callback(reply):
                if reply and context.job_queue:
                    context.job_queue.run_once(
                        lambda ctx: ctx.bot.send_message(
                            chat_id=query.message.chat_id,
                            text=reply,
                            parse_mode='HTML',
                            reply_to_message_id=message.message_id
                        ),
                        0
                    )
            generate_response(message.text, user_id, message.from_user.username or "Unknown", reply_callback)
    await query.message.delete()
# --- ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ init_db Ùˆ Ø§ÙØ²ÙˆØ¯Ù† Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ Ø¯Ø± main ---
async def main():
    init_db()
    application = Application.builder().token(TOKEN).build()
    
    # Add handlers
    application.add_handler(CommandHandler("warn", warn))
    application.add_handler(CommandHandler("violations", violations)) 
    application.add_handler(CommandHandler("clearviolations", clear_violations_cmd))
    application.add_handler(CommandHandler("admin", admin_start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(handle_callback_query, pattern="^(allow_|deny_).*$"))

    return application

application = None

app = FastAPI()

@app.post("/webhook")
async def webhook(request: Request):
    global application
    update = await request.json()
    update_obj = Update.de_json(update, application.bot)
    update_id = update_obj.update_id
    logger.info(f"Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§ update_id: {update_id}")
    async with PROCESSING_LOCK:
        if update_id in PROCESSED_MESSAGES:
            logger.warning(f"Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªÚ©Ø±Ø§Ø±ÛŒ Ø¨Ø§ update_id: {update_id} - Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯")
            return {"status": "ok"}
        PROCESSED_MESSAGES.add(update_id)
    asyncio.create_task(application.process_update(update_obj))
    return {"status": "ok"}

@app.get("/")
async def root():
    return {"message": "PlatoDex Bot is running!"}

def clean_text(text):
    if not text:
        return ""
    text = text.replace("*", "").replace("`", "").replace("[", "").replace("]", "").replace("!", "!")
    ad_texts = [
        "Powered by Pollinations.AI free text APIs. Support our mission(https://pollinations.ai/redirect/kofi) to keep AI accessible for everyone.",
        "ØªÙˆØ³Ø· Pollinations.AI Ø¨Ù‡ ØµÙˆØ±Øª Ø±Ø§ÛŒÚ¯Ø§Ù† Ø§Ø±Ø§Ø¦Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ø§Ø² Ù…Ø£Ù…ÙˆØ±ÛŒØª Ù…Ø§ Ø­Ù…Ø§ÛŒØª Ú©Ù†ÛŒØ¯(https://pollinations.ai/redirect/kofi) ØªØ§ AI Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ø§Ø´Ø¯."
    ]
    for ad_text in ad_texts:
        if ad_text in text:
            text = text.replace(ad_text, "").strip()
    return text.strip()

# ØªØ¹Ø±ÛŒÙ Ú©Ù„Ø§Ø³ PlatoItem
class PlatoItem:
    def __init__(
        self,
        id: str,
        name: str,
        category: str,
        description: str,
        price: Dict[str, Union[int, str]],
        images: List[str],
        audios: Optional[List[Dict[str, str]]] = None
    ):
        self.id = id
        self.name = name
        self.category = category
        self.description = description
        self.price = price
        self.images = images
        self.audios = audios

    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "category": self.category,
            "description": self.description,
            "price": self.price,
            "images": self.images,
            "audios": self.audios
        }

# Ø§Ø³Ú©Ø±Ù¾ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯
def scrape_leaderboard():
    url = "https://platoapp.com/en"
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"}
    try:
        response = requests.get(url, headers=headers, timeout=20)
        if response.status_code != 200:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯: {response.status_code}")
            return None
        soup = BeautifulSoup(response.content, 'html.parser')
        
        leaderboard_data = []
        leaderboard_section = None
        for div in soup.find_all('div', class_='rounded padded spaced panel'):
            if div.find('h2', string=lambda text: 'Leaderboard' in text if text else False):
                leaderboard_section = div
                break
        
        if not leaderboard_section:
            logger.error("Ø¨Ø®Ø´ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯!")
            return leaderboard_data
        
        players = leaderboard_section.find_all('a', class_='winner')
        for player in players:
            player_link = player['href']
            full_player_link = f"https://platoapp.com{player_link}"
            player_id = player_link.split('/')[3]
            username = player.find('strong', class_='user').text.strip() if player.find('strong', class_='user') else "Ø¨Ø¯ÙˆÙ† Ù†Ø§Ù…"
            profile_img = player.find('img', class_='round')
            profile_img_url = profile_img['src'] if profile_img else None
            profile_img_url = profile_img_url if profile_img_url and profile_img_url.startswith('http') else f"https://platoapp.com{profile_img_url}" if profile_img_url else None
            wins = player.find('strong', class_='count').text.strip() if player.find('strong', class_='count') else "0"
            
            leaderboard_data.append({
                'player_id': player_id,
                'player_link': full_player_link,
                'username': username,
                'profile_image': profile_img_url,
                'wins': wins
            })
        return leaderboard_data[:10]
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø³Ú©Ø±Ù¾ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯: {e}")
        return None

# Ø§Ø³Ú©Ø±Ù¾ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§Ø²ÛŒÚ©Ù†
def scrape_profile(player_link):
    try:
        response = requests.get(player_link, timeout=20)
        if response.status_code != 200:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø±ÙˆÙØ§ÛŒÙ„: {response.status_code}")
            return None
        soup = BeautifulSoup(response.content, "html.parser")
        
        games_data = []
        game_blocks = soup.find_all("div", class_="rounded relative")
        for block in game_blocks:
            icon_tag = block.find("img", class_="image")
            icon_url = icon_tag["src"] if icon_tag else "Ø¢ÛŒÚ©ÙˆÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯"
            name_tag = block.find("h2")
            game_name = name_tag.text.strip() if name_tag else "Ù†Ø§Ù… ÛŒØ§ÙØª Ù†Ø´Ø¯"
            stats = block.find("div", class_="stats grid")
            played = "0"
            won = "0"
            if stats:
                played_tag = stats.find("h3")
                won_tag = stats.find_all("h3")[1] if len(stats.find_all("h3")) > 1 else None
                played = played_tag.text.strip() if played_tag else "0"
                won = won_tag.text.strip() if won_tag else "0"
            games_data.append({"game_name": game_name, "played": played, "won": won})
        return games_data
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø³Ú©Ø±Ù¾ Ù¾Ø±ÙˆÙØ§ÛŒÙ„: {e}")
        return None

# Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯
async def show_leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_id = update.message.message_id
    async with PROCESSING_LOCK:
        if message_id in PROCESSED_MESSAGES:
            logger.warning(f"Ù¾ÛŒØ§Ù… ØªÚ©Ø±Ø§Ø±ÛŒ Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ø¨Ø§ message_id: {message_id} - Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯")
            return
        PROCESSED_MESSAGES.add(message_id)
    
    chat_id = update.effective_chat.id
    thread_id = update.message.message_thread_id if hasattr(update.message, 'is_topic_message') and update.message.is_topic_message else None
    
    try:
        await context.bot.get_chat(chat_id)
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ú†Øª {chat_id}: {e}")
        if "Forbidden" in str(e):
            await update.message.reply_text(clean_text("Ù…ØªØ£Ø³ÙÙ…ØŒ Ù…Ù† Ø§Ø² Ø§ÛŒÙ† Ú¯Ø±ÙˆÙ‡ Ø¨ÛŒØ±ÙˆÙ† Ø§Ù†Ø¯Ø§Ø®ØªÙ‡ Ø´Ø¯Ù…! ğŸ˜• Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ù…Ù†Ùˆ Ø§Ø¯ Ú©Ù† ØªØ§ Ú©Ù…Ú©Øª Ú©Ù†Ù…."), message_thread_id=thread_id)
        else:
            await update.message.reply_text(clean_text("ÛŒÙ‡ Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯ØŒ Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù… Ú†Øª Ø±Ùˆ Ù¾ÛŒØ¯Ø§ Ú©Ù†Ù…! ğŸ˜…"), message_thread_id=thread_id)
        return
    
    leaderboard_data = scrape_leaderboard()
    if not leaderboard_data:
        await update.message.reply_text(clean_text("Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯! ğŸ˜… Ø¨Ø¹Ø¯Ø§Ù‹ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."), message_thread_id=thread_id)
        return
    
    leaderboard_text = "ğŸ† Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø¨Ø±ØªØ±:\n\n"
    for i, player in enumerate(leaderboard_data, 1):
        leaderboard_text += f"{i}. {player['username']} - {player['wins']} Ø¨Ø±Ø¯\n"
    
    await update.message.reply_text(clean_text(leaderboard_text), message_thread_id=thread_id)

async def extract_items(context: ContextTypes.DEFAULT_TYPE = None):
    global EXTRACTED_ITEMS
    EXTRACTED_ITEMS = []
    max_retries = 3
    retry_delay = 5
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5"
    }

    for attempt in range(max_retries):
        try:
            logger.info(f"ØªÙ„Ø§Ø´ {attempt + 1} Ø¨Ø±Ø§ÛŒ Ø§Ø³Ú©Ø±Ù¾ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø§Ø² {URL}")
            response = requests.get(URL, headers=headers, timeout=30)
            logger.info(f"ÙˆØ¶Ø¹ÛŒØª Ù¾Ø§Ø³Ø®: {response.status_code}")

            if response.status_code != 200:
                logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±Ø®ÙˆØ§Ø³Øª HTTP: {response.status_code}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(retry_delay)
                continue

            soup = BeautifulSoup(response.text, "html.parser")

            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø§Ø² Ø§Ø³Ú©Ø±ÛŒÙ¾Øª
            items_data = {}
            script_tags = soup.find_all("script")
            for tag in script_tags:
                script_content = tag.string or ""
                # Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø§ÛŒ var items
                if "var items = {" in script_content:
                    match = re.search(r"var items = ({.*?});", script_content, re.DOTALL)
                    if match and match.group(1):
                        try:
                            items_data = json.loads(match.group(1))
                            logger.info(f"Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ù¾ÛŒØ¯Ø§ Ø´Ø¯ (var items): {len(items_data)} Ø¢ÛŒØªÙ…")
                            break
                        except json.JSONDecodeError as e:
                            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªØ¬Ø²ÛŒÙ‡ JSON Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ (var items): {e}")
                            continue
                # Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø§ÛŒ __PRELOADED_STATE__
                elif "__PRELOADED_STATE__" in script_content:
                    match = re.search(r"window\.__PRELOADED_STATE__ = ({.*?});", script_content, re.DOTALL)
                    if match and match.group(1):
                        try:
                            preload_data = json.loads(match.group(1))
                            items_data = preload_data.get("items", {}) or preload_data.get("data", {}).get("items", {})
                            logger.info(f"Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ù¾ÛŒØ¯Ø§ Ø´Ø¯ (__PRELOADED_STATE__): {len(items_data)} Ø¢ÛŒØªÙ…")
                            break
                        except json.JSONDecodeError as e:
                            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªØ¬Ø²ÛŒÙ‡ JSON Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ (__PRELOADED_STATE__): {e}")
                            continue

            if not items_data:
                logger.error("Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø¯Ø± Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯!")
                if attempt < max_retries - 1:
                    await asyncio.sleep(retry_delay)
                continue

            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¬Ø²Ø¦ÛŒØ§Øª Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø§Ø² Ø¬Ø¯ÙˆÙ„
            item_details = {}
            table = soup.find(id="tool_items_table_default")
            if table:
                rows = table.find("tbody").find_all("tr")
                logger.info(f"ØªØ¹Ø¯Ø§Ø¯ Ø±Ø¯ÛŒÙâ€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÙˆÙ„: {len(rows)}")
                for row in rows:
                    item_id = row.get("id", "").replace("id-", "")
                    if not item_id:
                        continue
                    cols = row.find_all("td")
                    item_columns = {f"column_{i+1}": col.get_text(strip=True) for i, col in enumerate(cols)}
                    price_text = item_columns.get("column_4", "0")
                    price_match = re.search(r"\d[\d,]*", price_text)
                    price_value = int(price_match.group(0).replace(",", "")) if price_match else 0
                    price_type = "premium" if price_value < 100 else "coins"
                    item_details[item_id] = {
                        "columns": item_columns,
                        "price": {"value": price_value, "type": price_type}
                    }

            # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§
            extracted_items = []
            for item_id, item_info in items_data.items():
                med = item_info.get("med", {})
                images = [BASE_IMAGE_URL + img["uri"] for img in med.get("images", [])]
                audios = [
                    {
                        "uri": audio["uri"],
                        "type": audio.get("type", "audio/mp4"),
                        "title": audio.get("title", f"{item_id} Audio")
                    }
                    for audio in med.get("audios", []) if med.get("audios")
                ] or []

                details = item_details.get(item_id, {})
                columns = details.get("columns", {})
                if columns:
                    extracted_item = PlatoItem(
                        id=item_id,
                        name=columns.get("column_3", "Unknown Item"),
                        category=columns.get("column_2", "Unknown"),
                        description=columns.get("column_5", "No description available"),
                        price=details.get("price", {"value": 0, "type": "unknown"}),
                        images=images,
                        audios=audios
                    )
                    extracted_items.append(extracted_item)

            EXTRACTED_ITEMS = [item.to_dict() for item in extracted_items]
            logger.info(f"ØªØ¹Ø¯Ø§Ø¯ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ú©Ø±Ù¾ Ø´Ø¯Ù‡: {len(EXTRACTED_ITEMS)}")

            if EXTRACTED_ITEMS:
                if context and hasattr(context.bot, "send_message"):
                    await context.bot.send_message(
                        chat_id=DEFAULT_CHAT_ID,
                        text=clean_text(f"Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯Ù†Ø¯! ØªØ¹Ø¯Ø§Ø¯: {len(EXTRACTED_ITEMS)}")
                    )
                return
            else:
                logger.warning("Ù‡ÛŒÚ† Ø¢ÛŒØªÙ…ÛŒ Ø§Ø³Ú©Ø±Ù¾ Ù†Ø´Ø¯!")
                if attempt < max_retries - 1:
                    await asyncio.sleep(retry_delay)

        except Exception as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø³Ú©Ø±Ù¾ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ (ØªÙ„Ø§Ø´ {attempt + 1}): {e}")
            if attempt < max_retries - 1:
                await asyncio.sleep(retry_delay)

    logger.error("Ø§Ø³Ú©Ø±Ù¾ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø¨Ø¹Ø¯ Ø§Ø² ØªÙ…Ø§Ù… ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯!")
    if context and hasattr(context.bot, "send_message"):
        await context.bot.send_message(
            chat_id=DEFAULT_CHAT_ID,
            text=clean_text("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§! Ø¨Ø¹Ø¯Ø§Ù‹ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯.")
        )

def schedule_scraping(app: Application):
    if app.job_queue is None:
        logger.error("JobQueue ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª!")
        raise RuntimeError("JobQueue ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª!")
    app.job_queue.run_repeating(extract_items, interval=12*60*60, first=0)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id in AI_CHAT_USERS:
        AI_CHAT_USERS.remove(user_id)
    context.user_data.clear()
    user_name = update.message.from_user.first_name
    welcome_message = clean_text(
        f"Ø³Ù„Ø§Ù… {user_name}!\nØ¨Ù‡ PlatoDex Ø®ÙˆØ´ Ø§ÙˆÙ…Ø¯ÛŒ - Ù…Ø±Ú©Ø² Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§ÛŒ Plato!\n"
        "â€¢ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø±Ùˆ Ø¨Ø¨ÛŒÙ† ğŸ²\nâ€¢ Ø±ØªØ¨Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§ Ø±Ùˆ Ú†Ú© Ú©Ù† ğŸ†\nâ€¢ Ø§Ø®Ø¨Ø§Ø± Ø±Ùˆ Ø¯Ù†Ø¨Ø§Ù„ Ú©Ù† ğŸ¯"
    )
    keyboard = [
        [InlineKeyboardButton("Run App ğŸ“±", web_app={"url": "https://v0-gram-file-mini-app.vercel.app"})],
        [InlineKeyboardButton("Search Items ğŸ”", callback_data="search_items")],
        [InlineKeyboardButton("Chat with AI ğŸ¤–", callback_data="chat_with_ai")],
        [InlineKeyboardButton("Generate Image ğŸ–¼ï¸", callback_data="generate_image")]
    ]
    await update.message.reply_text(welcome_message, reply_markup=InlineKeyboardMarkup(keyboard))
    return ConversationHandler.END

async def start_generate_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data.clear()
    keyboard = [
        [InlineKeyboardButton("512x512", callback_data="size_512x512")],
        [InlineKeyboardButton("1024x1024", callback_data="size_1024x1024")],
        [InlineKeyboardButton("1280x720", callback_data="size_1280x720")],
        [InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        clean_text("ğŸ–¼ï¸ Generate Image Mode Activated!\n\nÙ„Ø·ÙØ§Ù‹ Ø³Ø§ÛŒØ² ØªØµÙˆÛŒØ± Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"),
        reply_markup=reply_markup
    )
    return SELECT_SIZE

async def select_size(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    size = query.data
    if size == "size_512x512":
        context.user_data["width"] = 512
        context.user_data["height"] = 512
    elif size == "size_1024x1024":
        context.user_data["width"] = 1024
        context.user_data["height"] = 1024
    elif size == "size_1280x720":
        context.user_data["width"] = 1280
        context.user_data["height"] = 720
    keyboard = [[InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        clean_text(f"Ø³Ø§ÛŒØ² ØªØµÙˆÛŒØ± Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯: {context.user_data['width']}x{context.user_data['height']}\n\nÙ„Ø·ÙØ§Ù‹ ØªÙˆØ¶ÛŒØ­Ø§Øª ØªØµÙˆÛŒØ± (Ù¾Ø±Ø§Ù…Ù¾Øª) Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ù…Ø«Ù„Ø§Ù‹: 'A cat in a forest'"),
        reply_markup=reply_markup
    )
    return GET_PROMPT

async def get_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE):
    prompt = update.message.text.strip()
    if not prompt:
        await update.message.reply_text(clean_text("Ù„Ø·ÙØ§Ù‹ ÛŒÚ© ØªÙˆØ¶ÛŒØ­ Ø¨Ø±Ø§ÛŒ ØªØµÙˆÛŒØ± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯!"))
        return GET_PROMPT
    
    width = context.user_data["width"]
    height = context.user_data["height"]
    seed = random.randint(1, 999999)
    
    loading_message = await update.message.reply_text(clean_text("ğŸ–Œï¸ Ø¯Ø± Ø­Ø§Ù„ Ø·Ø±Ø§Ø­ÛŒ Ø¹Ú©Ø³... Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯."))
    
    api_url = f"{IMAGE_API_URL}{prompt}?width={width}&height={height}&nologo=true&seed={seed}"
    try:
        response = requests.get(api_url, timeout=30)
        if response.status_code == 200:
            await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=loading_message.message_id)
            keyboard = [
                [InlineKeyboardButton("â†©ï¸ Ø¨Ø±Ú¯Ø´Øª", callback_data="retry_generate_image")],
                [InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_photo(photo=response.content, reply_markup=reply_markup)
        else:
            await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=loading_message.message_id)
            await update.message.reply_text(clean_text("Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ù¾ÛŒØ´ Ø¢Ù…Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."))
    except Exception as e:
        await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=loading_message.message_id)
        await update.message.reply_text(clean_text("Ø®Ø·Ø§ÛŒÛŒ Ø±Ø® Ø¯Ø§Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ø¹Ø¯Ø§Ù‹ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."))
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ±: {e}")
    
    return ConversationHandler.END

async def retry_generate_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    keyboard = [
        [InlineKeyboardButton("512x512", callback_data="size_512x512")],
        [InlineKeyboardButton("1024x1024", callback_data="size_1024x1024")],
        [InlineKeyboardButton("1280x720", callback_data="size_1280x720")],
        [InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        clean_text("ğŸ–¼ï¸ Generate Image Mode Activated!\n\nÙ„Ø·ÙØ§Ù‹ Ø³Ø§ÛŒØ² ØªØµÙˆÛŒØ± Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"),
        reply_markup=reply_markup
    )
    return SELECT_SIZE

async def regenerate_group_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    logger.info(f"Ø¯Ú©Ù…Ù‡ ØªÙˆÙ„ÛŒØ¯ Ù…Ø¬Ø¯Ø¯ ØªØµÙˆÛŒØ± Ú©Ù„ÛŒÚ© Ø´Ø¯! callback_data: {query.data}")
    
    if not query.data.startswith("regenerate_image_"):
        logger.error("callback_data Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª!")
        await query.message.reply_text(clean_text("Ø®Ø·Ø§ÛŒÛŒ Ø±Ø® Ø¯Ø§Ø¯! Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯. ğŸ˜…"))
        return ConversationHandler.END
    
    prompt = query.data.replace("regenerate_image_", "", 1)
    if not prompt:
        logger.error("Ù¾Ø±Ø§Ù…Ù¾Øª Ø®Ø§Ù„ÛŒ Ø§Ø³Øª!")
        await query.message.reply_text(clean_text("Ù¾Ø±Ø§Ù…Ù¾Øª ØªØµÙˆÛŒØ± Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯! Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯. ğŸ˜…"))
        return ConversationHandler.END
    
    thread_id = query.message.message_thread_id if hasattr(query.message, 'is_topic_message') and query.message.is_topic_message else None
    chat_id = query.message.chat_id
    
    last_image_message_id = context.user_data.get("last_image_message_id")
    if last_image_message_id:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=last_image_message_id)
            logger.info(f"ØªØµÙˆÛŒØ± Ù‚Ø¨Ù„ÛŒ Ø¨Ø§ ID {last_image_message_id} Ø­Ø°Ù Ø´Ø¯.")
        except Exception as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ØªØµÙˆÛŒØ± Ù‚Ø¨Ù„ÛŒ: {e}")
            await query.message.reply_text(clean_text("Ù†Ø´Ø¯ ØªØµÙˆÛŒØ± Ù‚Ø¨Ù„ÛŒ Ø±Ùˆ Ù¾Ø§Ú© Ú©Ù†Ù…ØŒ ÙˆÙ„ÛŒ ÛŒÙ‡ ØªØµÙˆÛŒØ± Ø¬Ø¯ÛŒØ¯ Ù…ÛŒâ€ŒØ³Ø§Ø²Ù…! ğŸ˜…"))
    
    loading_message = await context.bot.send_message(
        chat_id=chat_id,
        text=clean_text("ğŸ–Œï¸ Ø¯Ø± Ø­Ø§Ù„ Ø·Ø±Ø§Ø­ÛŒ Ù…Ø¬Ø¯Ø¯ Ø¹Ú©Ø³... Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯."),
        message_thread_id=thread_id
    )
    
    seed = random.randint(1, 1000000)
    api_url = f"{IMAGE_API_URL}{prompt}?width=1024&height=1024&nologo=true&seed={seed}"
    try:
        response = requests.get(api_url, timeout=30)
        if response.status_code == 200:
            await context.bot.delete_message(chat_id=chat_id, message_id=loading_message.message_id)
            keyboard = [[InlineKeyboardButton("ğŸ”„ Ø·Ø±Ø§Ø­ÛŒ Ù…Ø¬Ø¯Ø¯ ØªØµÙˆÛŒØ±", callback_data=f"regenerate_image_{prompt}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            original_message_id = context.user_data.get("original_message_id", query.message.reply_to_message.message_id)
            message = await context.bot.send_photo(
                chat_id=chat_id,
                photo=response.content,
                caption=clean_text(f"ğŸª„ Ù¾Ø±Ø§Ù…Øª ØªØµÙˆÛŒØ± Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡ Ø´Ù…Ø§:\n\n{prompt}\n\n@PlatoDex"),
                reply_markup=reply_markup,
                message_thread_id=thread_id,
                reply_to_message_id=original_message_id
            )
            context.user_data["last_image_message_id"] = message.message_id
            logger.info(f"ØªØµÙˆÛŒØ± Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ message_id {message.message_id} Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.")
        else:
            await context.bot.delete_message(chat_id=chat_id, message_id=loading_message.message_id)
            await context.bot.send_message(
                chat_id=chat_id,
                text=clean_text("Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ù¾ÛŒØ´ Ø¢Ù…Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."),
                message_thread_id=thread_id
            )
    except Exception as e:
        await context.bot.delete_message(chat_id=chat_id, message_id=loading_message.message_id)
        await context.bot.send_message(
            chat_id=chat_id,
            text=clean_text("Ø®Ø·Ø§ÛŒÛŒ Ø±Ø® Ø¯Ø§Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ø¹Ø¯Ø§Ù‹ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."),
            message_thread_id=thread_id
        )
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ù…Ø¬Ø¯Ø¯ Ú¯Ø±ÙˆÙ‡: {e}")
    
    return ConversationHandler.END

async def start_group_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_id = update.message.message_id
    async with PROCESSING_LOCK:
        if message_id in PROCESSED_MESSAGES:
            logger.warning(f"Ù¾ÛŒØ§Ù… ØªÚ©Ø±Ø§Ø±ÛŒ Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ø¨Ø§ message_id: {message_id} - Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯")
            return
        PROCESSED_MESSAGES.add(message_id)
    
    chat_id = update.effective_chat.id
    try:
        await context.bot.get_chat(chat_id)
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ú†Øª {chat_id}: {e}")
        if "Forbidden" in str(e):
            await update.message.reply_text(clean_text("Ù…ØªØ£Ø³ÙÙ…ØŒ Ù…Ù† Ø§Ø² Ø§ÛŒÙ† Ú¯Ø±ÙˆÙ‡ Ø¨ÛŒØ±ÙˆÙ† Ø§Ù†Ø¯Ø§Ø®ØªÙ‡ Ø´Ø¯Ù…! ğŸ˜• Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ù…Ù†Ùˆ Ø§Ø¯ Ú©Ù† ØªØ§ Ú©Ù…Ú©Øª Ú©Ù†Ù…."))
        else:
            await update.message.reply_text(clean_text("ÛŒÙ‡ Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯ØŒ Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù… Ú†Øª Ø±Ùˆ Ù¾ÛŒØ¯Ø§ Ú©Ù†Ù…! ğŸ˜…"))
        return
    
    thread_id = update.message.message_thread_id if hasattr(update.message, 'is_topic_message') and update.message.is_topic_message else None
    
    if not context.args:
        await update.message.reply_text(
            clean_text(
                "ğŸ–Œï¸ Ù„Ø·ÙØ§Ù‹ Ù…ØªÙ†ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ø¨Ù‡ Ø¹Ú©Ø³ ØªØ¨Ø¯ÛŒÙ„ Ø¨Ø´Ù‡ Ø±Ùˆ Ø¨Ù‡ Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ Ø¨ÙØ±Ø³Øª!\n\n"
                "Ù…Ø«Ù„Ø§Ù‹:\n/p a woman"
            ),
            message_thread_id=thread_id
        )
        return
    
    prompt = " ".join(context.args).strip()
    if not prompt:
        await update.message.reply_text(
            clean_text("Ù¾Ø±Ø§Ù…Ù¾Øª Ø®Ø§Ù„ÛŒÙ‡! ÛŒÙ‡ ØªÙˆØ¶ÛŒØ­ Ø¨Ø±Ø§ÛŒ ØªØµÙˆÛŒØ± Ø¨Ø¯Ù‡. Ù…Ø«Ù„Ø§Ù‹: /p A flying car"),
            message_thread_id=thread_id
        )
        return
    seed = random.randint(1, 999999)
    loading_message = await update.message.reply_text(
        clean_text("ğŸ–Œï¸ Ø¯Ø± Ø­Ø§Ù„ Ø·Ø±Ø§Ø­ÛŒ Ø¹Ú©Ø³... Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯."),
        message_thread_id=thread_id
    )
    
    api_url = f"{IMAGE_API_URL}{prompt}?width=1024&height=1024&nologo=true&seed={seed}"
    try:
        response = requests.get(api_url, timeout=30)
        if response.status_code == 200:
            await context.bot.delete_message(chat_id=chat_id, message_id=loading_message.message_id)
            keyboard = [[InlineKeyboardButton("ğŸ”„ Ø·Ø±Ø§Ø­ÛŒ Ù…Ø¬Ø¯Ø¯ ØªØµÙˆÛŒØ±", callback_data=f"regenerate_image_{prompt}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            message = await context.bot.send_photo(
                chat_id=chat_id,
                photo=response.content,
                caption=clean_text(f"ğŸª„ Ù¾Ø±Ø§Ù…Øª ØªØµÙˆÛŒØ± Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡ Ø´Ù…Ø§:\n\n{prompt}\n\n@PlatoDex"),
                reply_markup=reply_markup,
                message_thread_id=thread_id,
                reply_to_message_id=update.message.message_id
            )
            context.user_data["last_image_message_id"] = message.message_id
            context.user_data["original_message_id"] = update.message.message_id
        else:
            await context.bot.delete_message(chat_id=chat_id, message_id=loading_message.message_id)
            await update.message.reply_text(
                clean_text("Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ù¾ÛŒØ´ Ø¢Ù…Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."),
                message_thread_id=thread_id
            )
    except Exception as e:
        await context.bot.delete_message(chat_id=chat_id, message_id=loading_message.message_id)
        await update.message.reply_text(
            clean_text("Ø®Ø·Ø§ÛŒÛŒ Ø±Ø® Ø¯Ø§Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ø¹Ø¯Ø§Ù‹ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."),
            message_thread_id=thread_id
        )
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ú¯Ø±ÙˆÙ‡: {e}")

async def inline_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.inline_query.query
    if not query:
        await update.inline_query.answer([])
        return
    results = []
    for item in EXTRACTED_ITEMS:
        if query.lower() in item["name"].lower() or query.lower() in item["category"].lower():
            price_type = "Pips" if item["price"]["type"] == "premium" else item["price"]["type"]
            price_info = clean_text(f"{item['price']['value']} {price_type}")
            result_content = (
                f"ğŸ”– Ù†Ø§Ù…: {item['name']}\n"
                f"\n"
                f"ğŸ—ƒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {item['category']}\n"
                f"ğŸ“ƒ ØªÙˆØ¶ÛŒØ­Ø§Øª: {item['description']}\n"
                f"\n"
                f"ğŸ’¸ Ù‚ÛŒÙ…Øª: {price_info}\n"
                f"ğŸ“£ @PlatoDex"
            )
            results.append(
                InlineQueryResultArticle(
                    id=item["id"],
                    title=item["name"],
                    description=f"{item['category']} - {price_info}",
                    input_message_content=InputTextMessageContent(result_content),
                    thumb_url=item["images"][0] if item["images"] else None
                )
            )
    await update.inline_query.answer(results[:50])

async def handle_inline_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_text = update.message.text
    item = next((i for i in EXTRACTED_ITEMS if i["name"] in message_text), None)
    if not item:
        return
    
    thread_id = update.message.message_thread_id if hasattr(update.message, 'is_topic_message') and update.message.is_topic_message else None
    price_type = "Pips" if item["price"]["type"] == "premium" else item["price"]["type"]
    price_info = clean_text(f"{item['price']['value']} {price_type}")
    results_text = (
        f"ğŸ”– Ù†Ø§Ù…: {item['name']}\n"
        f"\n"
        f"ğŸ—ƒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {item['category']}\n"
        f"ğŸ“ƒ ØªÙˆØ¶ÛŒØ­Ø§Øª: {item['description']}\n"
        f"\n"
        f"ğŸ’¸ Ù‚ÛŒÙ…Øª: {price_info}\n"
        f"ğŸ“£ @PlatoDex"
    )
    
    if item["images"]:
        await update.message.reply_photo(
            photo=item["images"][0],
            caption=results_text,
            message_thread_id=thread_id
        )
    else:
        await update.message.reply_text(
            results_text,
            message_thread_id=thread_id
        )
    
    for i, audio_info in enumerate(item["audios"], 1):
        await send_audio(update, context, item, audio_info, i, None, thread_id)

async def start_item_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data.clear()
    categories = sorted(set(item["category"] for item in EXTRACTED_ITEMS))
    context.user_data["categories"] = categories
    context.user_data["page"] = 0
    keyboard = [
        [InlineKeyboardButton("ğŸ” Ø¬Ø³Øªâ€ŒÙˆØ¬Ùˆ Ø¨Ø§ Ø§Ø³Ù…", callback_data="search_by_name")],
        [InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        clean_text("ğŸ” Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø±Ùˆ Ú†Ø·ÙˆØ±ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ù†ÛŒØŸ\nÛŒØ§ Ø§Ø² Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù† ÛŒØ§ Ø§Ø³Ù… Ø¢ÛŒØªÙ… Ø±Ùˆ Ø¨ÙØ±Ø³Øª!"),
        reply_markup=reply_markup
    )
    await send_paginated_categories(update, context, is_group=False)
    return SELECT_CATEGORY

async def search_by_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    keyboard = [[InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        clean_text("ğŸ” Ù„Ø·ÙØ§Ù‹ Ø§Ø³Ù… Ø¢ÛŒØªÙ… Ø±Ùˆ Ø¨ÙØ±Ø³Øª!"),
        reply_markup=reply_markup
    )
    return SEARCH_ITEM

async def process_item_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_id = update.message.message_id
    async with PROCESSING_LOCK:
        if message_id in PROCESSED_MESSAGES:
            logger.warning(f"Ù¾ÛŒØ§Ù… ØªÚ©Ø±Ø§Ø±ÛŒ Ø¯Ø± Ú†Øª Ø®ØµÙˆØµÛŒ Ø¨Ø§ message_id: {message_id} - Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯")
            return SEARCH_ITEM
        PROCESSED_MESSAGES.add(message_id)
    
    user_input = update.message.text.strip().lower()
    matching_items = [item for item in EXTRACTED_ITEMS if user_input in item["name"].lower() or user_input in item["category"].lower()]
    
    if not matching_items:
        keyboard = [[InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]]
        await update.message.reply_text(clean_text("Ù‡ÛŒÚ† Ø¢ÛŒØªÙ…ÛŒ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯! ğŸ˜•"), reply_markup=InlineKeyboardMarkup(keyboard))
        return SEARCH_ITEM
    
    context.user_data["matching_items"] = matching_items
    context.user_data["page"] = 0
    await send_paginated_items(update, context, is_group=False)
    return SEARCH_ITEM

async def send_paginated_items(update: Update, context: ContextTypes.DEFAULT_TYPE, is_group=False):
    matching_items = context.user_data["matching_items"]
    page = context.user_data.get("page", 0)
    items_per_page = 10
    total_pages = (len(matching_items) + items_per_page - 1) // items_per_page
    
    start_idx = page * items_per_page
    end_idx = min((page + 1) * items_per_page, len(matching_items))
    current_items = matching_items[start_idx:end_idx]
    
    if len(matching_items) == 1 and not is_group:
        item = matching_items[0]
        price_type = "Pips" if item["price"]["type"] == "premium" else item["price"]["type"]
        price_info = clean_text(f"{item['price']['value']} {price_type}")
        results_text = (
            f"ğŸ”– Ù†Ø§Ù…: {item['name']}\n"
            f"\n"
            f"ğŸ—ƒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {item['category']}\n"
            f"ğŸ“ƒ ØªÙˆØ¶ÛŒØ­Ø§Øª: {item['description']}\n"
            f"\n"
            f"ğŸ’¸ Ù‚ÛŒÙ…Øª: {price_info}\n"
            f"ğŸ“£ @PlatoDex"
        )
        keyboard = [[InlineKeyboardButton("â†©ï¸ Ø¨Ø±Ú¯Ø´Øª Ø¨Ù‡ Ù„ÛŒØ³Øª Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§", callback_data="back_to_items")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        if item["images"]:
            message = await update.message.reply_photo(photo=item["images"][0], caption=results_text, reply_markup=reply_markup)
        else:
            message = await update.message.reply_text(results_text, reply_markup=reply_markup)
        context.user_data["last_item_message_id"] = message.message_id
        for i, audio_info in enumerate(item["audios"], 1):
            await send_audio(update, context, item, audio_info, i, reply_markup)
        return
    
    keyboard = []
    for i, item in enumerate(current_items, start_idx + 1):
        price_type = "Pips" if item["price"]["type"] == "premium" else item["price"]["type"]
        price_info = clean_text(f"{item['price']['value']} {price_type}")
        button_text = clean_text(f"{i}. {item['name']} - {price_info}")
        callback_data = f"select{'_group' if is_group else ''}_item_{item['id']}"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
    
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("â¬…ï¸ Ù‚Ø¨Ù„ÛŒ", callback_data=f"prev_page_{'group' if is_group else 'private'}"))
    if page < total_pages - 1:
        nav_buttons.append(InlineKeyboardButton("Ø¨Ø¹Ø¯ÛŒ â¡ï¸", callback_data=f"next_page_{'group' if is_group else 'private'}"))
    if nav_buttons:
        keyboard.append(nav_buttons)
    if not is_group:
        keyboard.append([InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    message_text = clean_text(f"Ø§ÛŒÙ† Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø±Ùˆ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù… (ØµÙØ­Ù‡ {page + 1} Ø§Ø² {total_pages})ØŒ Ú©Ø¯ÙˆÙ… Ø±Ùˆ Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒØŸ ğŸ‘‡")
    
    async with PROCESSING_LOCK:
        if is_group and update.message:
            thread_id = update.message.message_thread_id if hasattr(update.message, 'is_topic_message') and update.message.is_topic_message else None
            message = await update.message.reply_text(message_text, reply_markup=reply_markup, message_thread_id=thread_id)
        elif update.callback_query:
            try:
                message = await update.callback_query.message.edit_text(message_text, reply_markup=reply_markup)
            except error.BadRequest as e:
                if "Message to edit not found" in str(e) or "There is no text in the message to edit" in str(e):
                    logger.warning(f"Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯ ÛŒØ§ Ù…ØªÙ† Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¬Ø¯ÛŒØ¯: {e}")
                    message = await update.callback_query.message.reply_text(message_text, reply_markup=reply_markup)
                else:
                    raise
        else:
            message = await update.message.reply_text(message_text, reply_markup=reply_markup)
        
        context.user_data["last_items_message_id"] = message.message_id

async def send_audio(update: Update, context: ContextTypes.DEFAULT_TYPE, item, audio_info, index, reply_markup=None, thread_id=None):
    audio_url = audio_info["uri"]
    audio_type = audio_info.get("type", "unknown")
    base_url = "https://game-assets-prod.platocdn.com/"
    full_url = base_url + audio_url if not audio_url.startswith("http") else audio_url
    message = update.message if update.message else (update.callback_query.message if update.callback_query else None)
    
    if not message:
        logger.error("Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ ÙˆÙˆÛŒØ³ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯!")
        return
    
    try:
        response = requests.get(full_url, timeout=20)
        if response.status_code == 200:
            with tempfile.NamedTemporaryFile(suffix=".ogg", delete=False) as temp_file:
                temp_file.write(response.content)
                temp_file_path = temp_file.name
            with open(temp_file_path, "rb") as voice_file:
                if thread_id:
                    await context.bot.send_voice(
                        chat_id=message.chat_id,
                        voice=voice_file,
                        caption=clean_text(audio_type),
                        message_thread_id=thread_id,
                        reply_markup=reply_markup
                    )
                else:
                    await context.bot.send_voice(
                        chat_id=message.chat_id,
                        voice=voice_file,
                        caption=clean_text(audio_type),
                        reply_markup=reply_markup
                    )
            os.remove(temp_file_path)
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø§Ù†Ù„ÙˆØ¯ ÛŒØ§ Ø§Ø±Ø³Ø§Ù„ ÙˆÙˆÛŒØ³ {index}: {e}")
        if thread_id:
            await message.reply_text(clean_text(f"Ù…Ø´Ú©Ù„ÛŒ ØªÙˆÛŒ Ø§Ø±Ø³Ø§Ù„ ÙˆÙˆÛŒØ³ {index} Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯! ğŸ˜…"), message_thread_id=thread_id)
        else:
            await message.reply_text(clean_text(f"Ù…Ø´Ú©Ù„ÛŒ ØªÙˆÛŒ Ø§Ø±Ø³Ø§Ù„ ÙˆÙˆÛŒØ³ {index} Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯! ğŸ˜…"))

async def select_item(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    item_id = query.data.replace("select_item_", "")
    item = next((i for i in EXTRACTED_ITEMS if i["id"] == item_id), None)
    
    if not item:
        await query.edit_message_text(clean_text("Ø¢ÛŒØªÙ… Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯! ğŸ˜•"))
        return SEARCH_ITEM
    
    price_type = "Pips" if item["price"]["type"] == "premium" else item["price"]["type"]
    price_info = clean_text(f"{item['price']['value']} {price_type}")
    results_text = (
        f"ğŸ”– Ù†Ø§Ù…: {item['name']}\n"
        f"\n"
        f"ğŸ—ƒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {item['category']}\n"
        f"ğŸ“ƒ ØªÙˆØ¶ÛŒØ­Ø§Øª: {item['description']}\n"
        f"\n"
        f"ğŸ’¸ Ù‚ÛŒÙ…Øª: {price_info}\n"
        f"ğŸ“£ @PlatoDex"
    )
    
    keyboard = [[InlineKeyboardButton("â†©ï¸ Ø¨Ø±Ú¯Ø´Øª Ø¨Ù‡ Ù„ÛŒØ³Øª Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§", callback_data="back_to_items")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    async with PROCESSING_LOCK:
        if item["images"]:
            message = await context.bot.send_photo(
                chat_id=query.message.chat_id,
                photo=item["images"][0],
                caption=results_text,
                reply_markup=reply_markup
            )
        else:
            message = await context.bot.send_message(
                chat_id=query.message.chat_id,
                text=results_text,
                reply_markup=reply_markup
            )
        context.user_data["last_item_message_id"] = message.message_id
    
        for i, audio_info in enumerate(item["audios"], 1):
            await send_audio(update, context, item, audio_info, i, reply_markup)
    
        last_items_message_id = context.user_data.get("last_items_message_id")
        if last_items_message_id:
            try:
                await context.bot.delete_message(chat_id=query.message.chat_id, message_id=last_items_message_id)
            except Exception as e:
                logger.warning(f"Ù¾ÛŒØ§Ù… Ù„ÛŒØ³Øª Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø¨Ø§ ID {last_items_message_id} Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯: {e}")
    
    return SEARCH_ITEM

async def back_to_items(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    async with PROCESSING_LOCK:
        last_item_message_id = context.user_data.get("last_item_message_id")
        if last_item_message_id:
            try:
                await context.bot.delete_message(chat_id=query.message.chat_id, message_id=last_item_message_id)
                logger.info(f"Ù¾ÛŒØ§Ù… Ø¢ÛŒØªÙ… Ø¨Ø§ ID {last_item_message_id} Ø­Ø°Ù Ø´Ø¯.")
                context.user_data.pop("last_item_message_id", None)
            except Exception as e:
                logger.warning(f"Ù¾ÛŒØ§Ù… Ø¢ÛŒØªÙ… Ø¨Ø§ ID {last_item_message_id} Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯: {e}")
        
        last_items_message_id = context.user_data.get("last_items_message_id")
        if last_items_message_id:
            try:
                await context.bot.delete_message(chat_id=query.message.chat_id, message_id=last_items_message_id)
                logger.info(f"Ù¾ÛŒØ§Ù… Ù„ÛŒØ³Øª Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø¨Ø§ ID {last_items_message_id} Ø­Ø°Ù Ø´Ø¯.")
                context.user_data.pop("last_items_message_id", None)
            except Exception as e:
                logger.warning(f"Ù¾ÛŒØ§Ù… Ù„ÛŒØ³Øª Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ Ø¨Ø§ ID {last_items_message_id} Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯: {e}")
    
    await send_paginated_items(update, context, is_group=False)
    return SEARCH_ITEM

async def process_item_in_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_id = update.message.message_id
    async with PROCESSING_LOCK:
        if message_id in PROCESSED_MESSAGES:
            logger.warning(f"Ù¾ÛŒØ§Ù… ØªÚ©Ø±Ø§Ø±ÛŒ Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ø¨Ø§ message_id: {message_id} - Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯")
            return
        PROCESSED_MESSAGES.add(message_id)
    
    chat_id = update.effective_chat.id
    try:
        await context.bot.get_chat(chat_id)
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ú†Øª {chat_id}: {e}")
        if "Forbidden" in str(e):
            await update.message.reply_text(clean_text("Ù…ØªØ£Ø³ÙÙ…ØŒ Ù…Ù† Ø§Ø² Ø§ÛŒÙ† Ú¯Ø±ÙˆÙ‡ Ø¨ÛŒØ±ÙˆÙ† Ø§Ù†Ø¯Ø§Ø®ØªÙ‡ Ø´Ø¯Ù…! ğŸ˜• Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ù…Ù†Ùˆ Ø§Ø¯ Ú©Ù† ØªØ§ Ú©Ù…Ú©Øª Ú©Ù†Ù…."))
        else:
            await update.message.reply_text(clean_text("ÛŒÙ‡ Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯ØŒ Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù… Ú†Øª Ø±Ùˆ Ù¾ÛŒØ¯Ø§ Ú©Ù†Ù…! ğŸ˜…"))
        return
    
    thread_id = update.message.message_thread_id if hasattr(update.message, 'is_topic_message') and update.message.is_topic_message else None
    
    if not context.args:
        categories = sorted(set(item["category"] for item in EXTRACTED_ITEMS))
        context.user_data["categories"] = categories
        context.user_data["page"] = 0
        await send_paginated_categories(update, context, is_group=True)
        return
    
    item_name = " ".join(context.args).strip().lower()
    matching_items = [item for item in EXTRACTED_ITEMS if item_name in item["name"].lower()]
    
    if not matching_items:
        await update.message.reply_text(
            clean_text(f"Ù…ØªØ£Ø³ÙÙ…ØŒ Ø¢ÛŒØªÙ…ÛŒ Ø¨Ø§ Ø§Ø³Ù… '{item_name}' Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯! ğŸ˜•"),
            message_thread_id=thread_id
        )
        return
    
    if len(matching_items) == 1:
        item = matching_items[0]
        price_type = "Pips" if item["price"]["type"] == "premium" else item["price"]["type"]
        price_info = clean_text(f"{item['price']['value']} {price_type}")
        results_text = (
            f"ğŸ”– Ù†Ø§Ù…: {item['name']}\n"
            f"\n"
            f"ğŸ—ƒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {item['category']}\n"
            f"ğŸ“ƒ ØªÙˆØ¶ÛŒØ­Ø§Øª: {item['description']}\n"
            f"\n"
            f"ğŸ’¸ Ù‚ÛŒÙ…Øª: {price_info}\n"
            f"ğŸ“£ @PlatoDex"
        )
        if item["images"]:
            await update.message.reply_photo(
                photo=item["images"][0],
                caption=results_text,
                reply_to_message_id=update.message.message_id,
                message_thread_id=thread_id
            )
        else:
            await update.message.reply_text(
                results_text,
                reply_to_message_id=update.message.message_id,
                message_thread_id=thread_id
            )
        for i, audio_info in enumerate(item["audios"], 1):
            await send_audio(update, context, item, audio_info, i, None, thread_id)
    else:
        context.user_data["matching_items"] = matching_items
        context.user_data["page"] = 0
        await send_paginated_items(update, context, is_group=True)

async def send_paginated_categories(update: Update, context: ContextTypes.DEFAULT_TYPE, is_group=False):
    categories = context.user_data.get("categories", sorted(set(item["category"] for item in EXTRACTED_ITEMS)))
    page = context.user_data.get("page", 0)
    items_per_page = 10
    total_pages = (len(categories) + items_per_page - 1) // items_per_page
    
    start_idx = page * items_per_page
    end_idx = min((page + 1) * items_per_page, len(categories))
    current_categories = categories[start_idx:end_idx]
    
    keyboard = []
    for i, category in enumerate(current_categories, start_idx + 1):
        callback_data = f"select_category_{category}"
        keyboard.append([InlineKeyboardButton(clean_text(f"{i}. {category}"), callback_data=callback_data)])
    
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("â¬…ï¸ Ù‚Ø¨Ù„ÛŒ", callback_data=f"prev_page_{'group' if is_group else 'private'}_categories"))
    if page < total_pages - 1:
        nav_buttons.append(InlineKeyboardButton("Ø¨Ø¹Ø¯ÛŒ â¡ï¸", callback_data=f"next_page_{'group' if is_group else 'private'}_categories"))
    if nav_buttons:
        keyboard.append(nav_buttons)
    if not is_group:
        keyboard.append([InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    message_text = clean_text(f"Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ (ØµÙØ­Ù‡ {page + 1} Ø§Ø² {total_pages})ØŒ Ú©Ø¯ÙˆÙ… Ø±Ùˆ Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒØŸ ğŸ‘‡")
    
    async with PROCESSING_LOCK:
        if is_group and update.message:
            thread_id = update.message.message_thread_id if hasattr(update.message, 'is_topic_message') and update.message.is_topic_message else None
            await update.message.reply_text(message_text, reply_markup=reply_markup, message_thread_id=thread_id)
        elif update.callback_query:
            try:
                await update.callback_query.message.edit_text(message_text, reply_markup=reply_markup)
            except error.BadRequest as e:
                if "Message to edit not found" in str(e):
                    logger.warning(f"Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯ØŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¬Ø¯ÛŒØ¯: {e}")
                    await update.callback_query.message.reply_text(message_text, reply_markup=reply_markup)
                else:
                    raise
        else:
            await update.message.reply_text(message_text, reply_markup=reply_markup)

async def select_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    category = query.data.replace("select_category_", "")
    matching_items = [item for item in EXTRACTED_ITEMS if item["category"] == category]
    
    if not matching_items:
        await query.edit_message_text(clean_text(f"Ù‡ÛŒÚ† Ø¢ÛŒØªÙ…ÛŒ ØªÙˆ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ '{category}' Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯! ğŸ˜•"))
        return SELECT_CATEGORY
    
    context.user_data["matching_items"] = matching_items
    context.user_data["page"] = 0
    await send_paginated_items(update, context, is_group="group" in query.data)
    return SEARCH_ITEM

async def select_group_item(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    item_id = query.data.replace("select_group_item_", "")
    item = next((i for i in EXTRACTED_ITEMS if i["id"] == item_id), None)
    thread_id = query.message.message_thread_id if hasattr(query.message, 'is_topic_message') and query.message.is_topic_message else None
    
    if not item:
        await query.message.reply_text(clean_text("Ø¢ÛŒØªÙ… Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯! ğŸ˜•"), message_thread_id=thread_id)
        return
    
    price_type = "Pips" if item["price"]["type"] == "premium" else item["price"]["type"]
    price_info = clean_text(f"{item['price']['value']} {price_type}")
    results_text = (
        f"ğŸ”– Ù†Ø§Ù…: {item['name']}\n"
        f"\n"
        f"ğŸ—ƒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {item['category']}\n"
        f"ğŸ“ƒ ØªÙˆØ¶ÛŒØ­Ø§Øª: {item['description']}\n"
        f"\n"
        f"ğŸ’¸ Ù‚ÛŒÙ…Øª: {price_info}\n"
        f"ğŸ“£ @PlatoDex"
    )
    
    async with PROCESSING_LOCK:
        if item["images"]:
            image_url = item["images"][0]
            if image_url.lower().endswith('.webp'):
                async def process_webp():
                    try:
                        response = requests.get(image_url, timeout=20)
                        response.raise_for_status()
                        img = Image.open(io.BytesIO(response.content))
                        gif_buffer = io.BytesIO()
                        if img.mode != 'RGBA':
                            img = img.convert('RGBA')
                        img.save(gif_buffer, format='GIF', save_all=True, optimize=True)
                        gif_buffer.seek(0)
                        input_file = InputFile(gif_buffer, filename="animation.gif")
                        await query.message.reply_animation(
                            animation=input_file,
                            caption=results_text,
                            message_thread_id=thread_id
                        )
                        for i, audio_info in enumerate(item["audios"], 1):
                            await send_audio(update, context, item, audio_info, i, None, thread_id)
                    except Exception as e:
                        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªØ¨Ø¯ÛŒÙ„ WebP: {e}")
                        await query.message.reply_text(clean_text("Ù…Ø´Ú©Ù„ÛŒ ØªÙˆÛŒ Ø§Ø±Ø³Ø§Ù„ Ø¹Ú©Ø³ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯! ğŸ˜…"), message_thread_id=thread_id)
                asyncio.create_task(process_webp())
            elif image_url.lower().endswith('.gif'):
                await query.message.reply_animation(
                    animation=image_url,
                    caption=results_text,
                    message_thread_id=thread_id
                )
                for i, audio_info in enumerate(item["audios"], 1):
                    await send_audio(update, context, item, audio_info, i, None, thread_id)
            else:
                await query.message.reply_photo(
                    photo=image_url,
                    caption=results_text,
                    message_thread_id=thread_id
                )
                for i, audio_info in enumerate(item["audios"], 1):
                    await send_audio(update, context, item, audio_info, i, None, thread_id)
        else:
            await query.message.reply_text(results_text, message_thread_id=thread_id)

async def handle_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    is_group = "group" in query.data
    page = context.user_data.get("page", 0)
    
    async with PROCESSING_LOCK:
        if "categories" in query.data:
            if "next_page" in query.data:
                context.user_data["page"] = page + 1
            elif "prev_page" in query.data:
                context.user_data["page"] = max(0, page - 1)
            await send_paginated_categories(update, context, is_group=is_group)
            return SELECT_CATEGORY if not is_group else None
        else:
            if "next_page" in query.data:
                context.user_data["page"] = page + 1
            elif "prev_page" in query.data:
                context.user_data["page"] = max(0, page - 1)
            await send_paginated_items(update, context, is_group=is_group)
            return SEARCH_ITEM if not is_group else None

async def chat_with_ai(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    AI_CHAT_USERS.add(user_id)
    context.user_data.clear()
    context.user_data["mode"] = "ai_chat"
    context.user_data["chat_history"] = []
    keyboard = [[InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        clean_text("ğŸ¤– Ú†Øª Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯!\n\nÙ‡Ø± Ú†ÛŒ Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ø¨Ú¯ÙˆØŒ Ù…Ù† ÛŒØ§Ø¯Ù… Ù…ÛŒâ€ŒÙ…ÙˆÙ†Ù‡ Ú†ÛŒ Ú¯ÙØªÛŒ! ğŸ˜"),
        reply_markup=reply_markup
    )
    return ConversationHandler.END

async def handle_ai_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in AI_CHAT_USERS or context.user_data.get("mode") != "ai_chat":
        return ConversationHandler.END
    
    user_message = update.message.text
    chat_history = context.user_data.get("chat_history", [])
    chat_history.append({"role": "user", "content": user_message})
    context.user_data["chat_history"] = chat_history
    
    payload = {
        "messages": [
            {"role": "system", "content": SYSTEM_MESSAGE}
        ] + chat_history,
        "model": "openai-large",
        "seed": 42,
        "jsonMode": False
    }
    
    keyboard = [[InlineKeyboardButton("ğŸ  Back to Home", callback_data="back_to_home")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    try:
        response = requests.post(TEXT_API_URL, json=payload, timeout=20)
        if response.status_code == 200:
            ai_response = clean_text(response.text.strip())
            chat_history.append({"role": "assistant", "content": ai_response})
            context.user_data["chat_history"] = chat_history
            await update.message.reply_text(ai_response, reply_markup=reply_markup)
        else:
            await update.message.reply_text(
                clean_text("Ø§ÙˆÙÙØŒ ÛŒÙ‡ Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯! ğŸ˜… ÙÚ©Ø± Ú©Ù†Ù… API ÛŒÙ‡ Ú©Ù… Ø®ÙˆØ§Ø¨Ø´ Ø¨Ø±Ø¯Ù‡! Ø¨Ø¹Ø¯Ø§Ù‹ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù† ğŸš€"),
                reply_markup=reply_markup
            )
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ API Ú†Øª: {e}")
        await update.message.reply_text(
            clean_text("Ø§ÛŒÛŒÛŒØŒ ÛŒÙ‡ Ø®Ø·Ø§ Ø®ÙˆØ±Ø¯Ù…! ğŸ˜­ Ø¨Ø¹Ø¯Ø§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨ÛŒØ§ØŒ Ù‚ÙˆÙ„ Ù…ÛŒâ€ŒØ¯Ù… Ø¯Ø±Ø³ØªØ´ Ú©Ù†Ù…! ğŸš€"),
            reply_markup=reply_markup
        )
    
    return ConversationHandler.END

async def handle_group_ai_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_id = update.message.message_id
    async with PROCESSING_LOCK:
        if message_id in PROCESSED_MESSAGES:
            logger.warning(f"Ù¾ÛŒØ§Ù… ØªÚ©Ø±Ø§Ø±ÛŒ Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ø¨Ø§ message_id: {message_id} - Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯")
            return
        PROCESSED_MESSAGES.add(message_id)
    
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id
    thread_id = update.message.message_thread_id if hasattr(update.message, 'is_topic_message') and update.message.is_topic_message else None
    user_message = update.message.text.lower()
    replied_message = update.message.reply_to_message

    group_history = context.bot_data.get("group_history", {}).get(chat_id, [])
    group_history.append({"user_id": user_id, "content": user_message, "message_id": message_id})
    context.bot_data["group_history"] = {chat_id: group_history}

    user_history = context.user_data.get("group_chat_history", [])
    
    should_reply = (
        "Ø±Ø¨Ø§Øª" in user_message or "Ù¾Ù„Ø§ØªÙˆ" in user_message or "Ø³Ù„Ø§Ù…" in user_message or "Ø®Ø¯Ø§Ø­Ø§ÙØ¸" in user_message or
        (replied_message and replied_message.from_user.id == context.bot.id)
    )
    
    if not should_reply:
        return
    
    if replied_message and replied_message.from_user.id == context.bot.id:
        user_history.append({"role": "assistant", "content": replied_message.text})
    
    user_history.append({"role": "user", "content": user_message})
    context.user_data["group_chat_history"] = user_history
    
    payload = {
        "messages": [
            {"role": "system", "content": SYSTEM_MESSAGE}
        ] + user_history,
        "model": "openai-large",
        "seed": 42,
        "jsonMode": False
    }
    
    try:
        response = requests.post(TEXT_API_URL, json=payload, timeout=20)
        if response.status_code == 200:
            ai_response = clean_text(response.text.strip())
            user_history.append({"role": "assistant", "content": ai_response})
            context.user_data["group_chat_history"] = user_history
            await update.message.reply_text(ai_response, message_thread_id=thread_id)
        else:
            await update.message.reply_text(
                clean_text("Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯! ğŸ˜… Ø¨Ø¹Ø¯Ø§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù† ğŸš€"),
                message_thread_id=thread_id
            )
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ API Ú†Øª Ú¯Ø±ÙˆÙ‡: {e}")
        await update.message.reply_text(
            clean_text("Ø®Ø·Ø§ÛŒÛŒ Ø±Ø® Ø¯Ø§Ø¯! ğŸ˜­ Ø¨Ø¹Ø¯Ø§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù† ğŸš€"),
            message_thread_id=thread_id
        )

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id in AI_CHAT_USERS:
        AI_CHAT_USERS.remove(user_id)
    context.user_data.clear()
    await update.message.reply_text(clean_text("Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯! ğŸ˜Š Ù‡Ø± ÙˆÙ‚Øª Ø®ÙˆØ§Ø³ØªÛŒ Ø¨Ø±Ú¯Ø±Ø¯!"))
    return ConversationHandler.END

async def back_to_home(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    if user_id in AI_CHAT_USERS:
        AI_CHAT_USERS.remove(user_id)
    context.user_data.clear()
    welcome_message = clean_text(
        "ğŸ  Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø®ÙˆØ´ Ø§ÙˆÙ…Ø¯ÛŒ!\n\nÚ†ÛŒ Ø¯ÙˆØ³Øª Ø¯Ø§Ø±ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø¨Ø¯ÛŒÙ…ØŸ ğŸ˜"
    )
    keyboard = [
        [InlineKeyboardButton("Run App ğŸ“±", web_app={"url": "https://v0-gram-file-mini-app.vercel.app"})],
        [InlineKeyboardButton("Search Items ğŸ”", callback_data="search_items")],
        [InlineKeyboardButton("Chat with AI ğŸ¤–", callback_data="chat_with_ai")],
        [InlineKeyboardButton("Generate Image ğŸ–¼ï¸", callback_data="generate_image")]
    ]
    await query.edit_message_text(welcome_message, reply_markup=InlineKeyboardMarkup(keyboard))
    return ConversationHandler.END

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¢Ù¾Ø¯ÛŒØª: {context.error}")
    if update and update.effective_message:
        await update.effective_message.reply_text(clean_text("Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯! ğŸ˜… Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."))

async def main():
    global application
    max_retries = 3
    retry_delay = 5
    
    for attempt in range(max_retries):
        try:
            application = Application.builder().token(TOKEN).read_timeout(60).write_timeout(60).connect_timeout(60).build()
            
            await application.initialize()
            logger.info("Application Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø´Ø¯.")
            
            if application.job_queue is None:
                logger.error("JobQueue ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª!")
                raise RuntimeError("JobQueue ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª!")
            
            await application.bot.set_webhook(url=WEBHOOK_URL)
            logger.info(f"Webhook Ø±ÙˆÛŒ {WEBHOOK_URL} ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯.")
            
            schedule_scraping(application)
            await extract_items()
            
            search_conv_handler = ConversationHandler(
                entry_points=[CallbackQueryHandler(start_item_search, pattern="^search_items$")],
                states={
                    SELECT_CATEGORY: [
                        CallbackQueryHandler(search_by_name, pattern="^search_by_name$"),
                        CallbackQueryHandler(select_category, pattern="^select_category_"),
                        CallbackQueryHandler(handle_pagination, pattern="^(prev|next)_page_private_categories$")
                    ],
                    SEARCH_ITEM: [
                        MessageHandler(filters.TEXT & ~filters.COMMAND, process_item_search),
                        CallbackQueryHandler(select_item, pattern="^select_item_"),
                        CallbackQueryHandler(back_to_items, pattern="^back_to_items$"),
                        CallbackQueryHandler(handle_pagination, pattern="^(prev|next)_page_private$")
                    ]
                },
                fallbacks=[
                    CommandHandler("cancel", cancel),
                    CommandHandler("start", start),
                    CallbackQueryHandler(back_to_home, pattern="^back_to_home$")
                ],
                name="item_search",
                persistent=False
            )

            image_conv_handler = ConversationHandler(
                entry_points=[
                    CallbackQueryHandler(start_generate_image, pattern="^generate_image$"),
                    CallbackQueryHandler(retry_generate_image, pattern="^retry_generate_image$")
                ],
                states={
                    SELECT_SIZE: [CallbackQueryHandler(select_size, pattern="^size_")],
                    GET_PROMPT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_prompt)]
                },
                fallbacks=[
                    CommandHandler("cancel", cancel),
                    CommandHandler("start", start),
                    CallbackQueryHandler(back_to_home, pattern="^back_to_home$")
                ],
                name="image_generation",
                persistent=False
            )

            group_image_conv_handler = ConversationHandler(
                entry_points=[
                    CommandHandler("p", start_group_image, filters=filters.ChatType.GROUPS),
                    CallbackQueryHandler(regenerate_group_image, pattern="^regenerate_image_")
                ],
                states={},
                fallbacks=[
                    CommandHandler("cancel", cancel),
                    CommandHandler("start", start)
                ],
                name="group_image_generation",
                persistent=False
            )

            application.add_handler(CommandHandler("start", start))
            application.add_handler(CommandHandler("cancel", cancel))
            application.add_handler(CallbackQueryHandler(chat_with_ai, pattern="^chat_with_ai$"))
            application.add_handler(search_conv_handler)
            application.add_handler(image_conv_handler)
            application.add_handler(group_image_conv_handler)
            application.add_handler(InlineQueryHandler(inline_query))
            application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.Regex(r'^@PlatoDex\s+\w+'), handle_inline_selection))
            application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE, handle_ai_message))
            application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.ChatType.GROUPS, handle_group_ai_message))
            application.add_handler(CommandHandler("item", process_item_in_group, filters=filters.ChatType.GROUPS))
            application.add_handler(CommandHandler("i", process_item_in_group, filters=filters.ChatType.GROUPS))
            application.add_handler(CommandHandler("w", show_leaderboard, filters=filters.ChatType.GROUPS))
            application.add_handler(CallbackQueryHandler(select_group_item, pattern="^select_group_item_"))
            application.add_error_handler(error_handler)

            port = int(os.getenv("PORT", 8000))
            config = uvicorn.Config(app, host="0.0.0.0", port=port)
            server = uvicorn.Server(config)
            await server.serve()

            return

        except Exception as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªÙ„Ø§Ø´ {attempt + 1}/{max_retries}: {e}")
            if attempt < max_retries - 1:
                logger.info(f"ØªÙ„Ø§Ø´ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨Ø¹Ø¯ Ø§Ø² {retry_delay} Ø«Ø§Ù†ÛŒÙ‡...")
                await asyncio.sleep(retry_delay)
            else:
                logger.error("Ù‡Ù…Ù‡ ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø±Ø¨Ø§Øª Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯!")
                raise

if __name__ == "__main__":
    asyncio.run(main())
